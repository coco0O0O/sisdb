
# 配置文件说明：
# 在 sisdb 系统中没有表的概念，取而代之的是字段和字段集
# 字段可以是一个，也可以是多个字段的嵌套和组合，组合后的成为字段集合

# 应该没有浮点数的概念，所有数据都是整型
# CHAR  16 0 定长字符串 最大255个字节 最大65K字符
# INT   4 0
# FLOAT 4 2 表示4字节存数据，还原的数据除以100，保留两位小数
# UINT  8 0 一个字节为长度，一个字节为0 浮点数第二字节为小数点位数
# JSON  10000  JSON格式类型 无长度限制，以A.B.C.D获取数据

# 时间尺度一共四种，只能从上往下降纬，不能升
# MSEC
# SECOND
# MIN1
# MIN5
# DAY

# 必须保证所有数据按时间顺序写入
# 如果写入数据时间小于当前保存时间，就需要初始化那一个时间之后的同一交易日的所有数据，并更新保存时间
#   这样当日即使多处理几次，也不会出错了
# 如果写入数据时间为新的一个交易日，需要初始化具备初始化属性的表，根据开收市时间来确定是否开始交易，以now为触发点
# 系统表应该有四个： 
#   管理每个品种什么时候开始交易，交易时段，
#   exch : 市场控制信息 - 内部处理
#     country   : [char,  4], # 国别 CN US 等
#     timezone  : [uint,  4], # 时区 
#     market    : [char,  3], # 市场编号 SH SZ 和key值一样
#     work-time : [ uint, 2, 2], 第一个为开始时间，第二个为结束时间
#     trade-nums : [ U, 1],
#     trade-time : [ uint, 2, 10], 一共可以保留5个时间段
#     status    : [uint,  1], # 状态，0 初始化 1 正常运行， 2 收盘开始 3 已经收盘
#     init-time : [uint,  4], # 版本号，初始化时生成的时间, 重新开机后，日期相同，不再初始化
#     init-date : [uint,  4], # 当前交易的日期 20180101
#     close-date: [uint,  4]  # 收盘日期 开市期间比tradedate小，收市后一样

#   每个股票单独处理，不再归属于某某市场了，
#   实际代码为 市场号+场内代码
#   每个股票的信息，价格保留小数点，价格放大倍数（除），成交量单位（乘）等
#   info
#     market  : [char,  3],
#     code    : [char,  7],    # key值是market+code的组合，
#     name    : [char, 16],
#     search  : [char, 16],
#     type    : [uint,  1],    # 股票类型  
#     pdot     : [uint,  1],    # 价格保留的小数点 默认为2
#     #价格在数据库的二进制表示为整数，json来源数据按小数点位数乘后存入二进制表示中
#     pzoom   : [uint,  4], # 价格单位，默认为1倍，留给比特币使用 最大10亿倍 
#     vunit   : [uint,  4]  

#   动态数据广播，不保留记录，直接生成其他数据表的数据格式，直接写入，
#   采用动态数据转换技术，转成下面的数据表
#   dyna
#   {
#     scale : SECOND,
#     程序启动后为每个数据保留两条记录，一条前一节点数据，和最后一条数据，最后一条数据用来检查vol是否增大，前一节点用来计算差额
#     一旦新进来的日期小于最后一条数据的时间，需要清理所有保留的记录，重新生成数据
#     publishs: {
#       snapshot:{

#       }, # 当日快照
#       tick:{

#       }, # 当日表
#       min:{

#       }, # 当日表
#       min1:{ 

#       },
#       min5:{

#       },
#       day:{

#       }
#   }

  
#   catch : 1,    # 最大记录数, 默认为0，不控制记录数， 1d表示为保留最新一天数据，
#   write-method : ,   # 新增记录的判定方法
# 总共3种方法名 ： 
# 所有有scale的数据表都默认以time为顺序，写入数据时首先要判断time的位置
# 只有当 time 比所有值都大或者等于最后的 time，才会判断 subscribe 的数据写入，小于的情况转入定位插入
# 插入数据前分两种情况  1是如果是新时间，需判断append是否成立，成立才插，不成立不插
# 如果是已经存在的时间，首先定位到这里，不成立就直接修改，

#   isinit :        # 是否做初始化，主要针对当天实时数据, 会清理掉当前证券当前字段的所有数据
#   publishs: "min,tick,day,min5,mday", # 需要扩散信息到其他的字段集合定义
#   subscribe-method : 方法名
# }

now: {
  scale : SECOND, # 有scale，默认按time索引
  limit : 1,      # 单只股票最大记录数
  isinit : 1,     # 是否每天做初始化，主要针对当天实时数据
  publishs: "min,tick,mday,min5,day", # 需要扩散信息到其他的表,对应表中需要subscribe-method定义，如果没有，默认原样拷贝，
  # publishs: "min5", # 需要扩散信息到其他的表,对应表中需要subscribe-method定义，如果没有，默认原样拷贝，
  fields: {
  # 字段名 : 数据类型 | 长度 | 重复数(默认为1) | 小数点数(默认为0) 
    time    : [second, 4],  # 直接根据format的类型生成time的类型
    open    : [price,  4],
    high    : [price,  4],
    low     : [price,  4],
    close   : [price,  4],
    vol     : [uint,   4],
    money   : [uint,   4],
    before  : [price,  4],  # 前收盘  ??? 放这里很方便，但也很难受，只能等以后支持json数据表再来处理
    stophigh: [price,  4],  # 最高限价
    stoplow : [price,  4],  # 最低限价
    askp    : [price,  4, 5],  # 表示后面跟10个同样的字段，字段名为askp1...askp10
    askv    : [uint,   4, 5],
    bidp    : [price,  4, 5],
    bidv    : [uint,   4, 5]
  }
}

# 每笔成交的明细表
tick:{
  scale : second, # 按秒增补
  limit : 1200, # 单只股票最大记录数
  isinit : 1,
  fields: {
# 字段名| 数据类型| 长度|
    time  : [second,  4],
    close : [price,   4],
    vol   : [uint,  4]
  },
  write-method : { 
    sort : "time",  # 以哪个字段进行排序，只能有一个字段
    checked : { $incr: "vol" } # 对数据合法性的检查， ,注意有订阅和无订阅的参照不同
  }
}

# 分钟线
min:{
  scale : incr,  # 按递增自然数 需要依赖tradetime，避免交易时间外的数据存在
  limit : 240, # 单只股票最大记录数 0 表示不限制
  isinit : 1,
  fields: {
  # 字段名| 数据类型| 长度|
    time  : [uint,   4],
    open  : [price,  4],
    high  : [price,  4],
    low   : [price,  4],
    close : [price,  4],
    vol   : [uint,   4],
    money : [uint,   4]
  },
  write-method : { 
    sort : "time",  # 以哪个字段进行排序，只能有一个字段
    solely : "time",  # 可多个字段，表示不能重复，重复即代表修改，以time排序
    checked : { $incr: "vol" } # 对数据合法性的检查， ,注意有订阅和无订阅的参照不同
  },
  subscribe-method : {
    # 字段名| 和front比较的方法| 产生新数据的参考字段
    open: { $once : "close"},   # once 仅仅在生成新数据时赋值 其他任何时候不变
    high: { $max : "close"},   # 求最大值，以close为基准 第一个记录直接赋值close
    low:  { $min : "close"}
  }
  # 有这个字段表示当从其他数据publish写入数据时，需要对数组中字段运算
}

#-------------盘后数据------------------
# 日线 其他周月年，和多日K线由此生成，提供数据生产接口
day:{
  scale : date,    # 按天增补
  fields: {
  # 字段名| 数据类型| 长度|
    time  : [date,   4],
    open  : [price,  4],
    high  : [price,  4],
    low   : [price,  4],
    close : [price,  4],
    vol   : [uint,   4],
    money : [uint,   4]
  },
  write-method : { 
    sort : "time",  # 以哪个字段进行排序，只能有一个字段
    solely : "time",  # 可多个字段，表示不能重复，重复即代表修改
    checked : { $nonzero: "vol" } # 对数据合法性的检查， ,注意有订阅和无订阅的参照不同
  }
}
# 先检查来源数据合法性
# 再判断字段唯一性，定位
# 最后判断前插后插还是修改
# 多日线，根据数据多寡可以显示多天的走势图
mday:{
  scale : min1, # 按1分钟增补
  limit : 1200, # 单只股票最大记录数 约5日数据
  fields: {
  # 字段名| 数据类型| 长度|
    time  : [second, 4],
    close : [price,  4],
    vol   : [uint, 4]
  },
  write-method : { 
    sort : "time",  # 以哪个字段进行排序，只能有一个字段
    solely : "time",  # 可多个字段，表示不能重复，重复即代表修改
    checked : { $incr: "vol" } # 对数据合法性的检查， ,注意有订阅和无订阅的参照不同
  },
  subscribe-method : {
    vol:  { $gap : "vol"}
  }
  # 有这个字段表示当从其他数据publish写入数据时，需要对数组中字段运算
}
# 5分钟线，其他分钟线由此生成，提供数据生产接口
min5:{
  scale : min5, # 按5分钟增补
  limit : 4800, # 单只股票最大记录数
  fields: {
  # 字段名| 数据类型| 长度|
    time  : [second, 4],
    open  : [price,  4],
    high  : [price,  4],
    low   : [price,  4],
    close : [price,  4],
    vol   : [uint,   4],
    money : [uint,   4]
  },
  write-method : { 
    sort : "time",  # 以哪个字段进行排序，只能有一个字段
    solely : "time",  # 可多个字段，表示不能重复，重复即代表修改
    checked : { $incr: "vol" } # 对数据合法性的检查， ,注意有订阅和无订阅的参照不同
  },
  subscribe-method : {
    # 字段名| 和front比较的方法| 产生新数据的参考字段
    open: { $once : "close"},   # once 仅仅在生成新数据时赋值 其他任何时候不变
    high: { $max : "close"},    # 求最大值，以close为基准 第一个记录直接赋值close
    low:  { $min : "close"},
    vol:  { $gap : "vol" },
    money:{ $gap : "money"}
  }
  # 有这个字段表示当从其他数据publish写入数据时，需要对数组中字段运算
}

# ------------------------------------------------------------------#
# 这里定义和财务相关的表格，以及其他扩展的数据表
# 此处似乎应该定义一个嵌套的树形表，还没有想好，先按结构化来处理
# 设想中应该也具备时序数据特性，但是字段却是树形结构的，集中的定义一系列字段和字段组合后，其他任何表格都可以直接引用

# 除权表
right:{
  scale : date, # 按天增补
  write-method : { 
    sort : "time",  # 以哪个字段进行排序，只能有一个字段
    solely : "time"  # 可多个字段，表示不能重复，重复即代表修改
  },  
  fields: {
  # 字段名| 数据类型| 长度|
    time      : [date, 4],
    prc-factor: [int,  8],  #价格因子 10000 正代表价格跌，负代表价格涨
    vol-factor: [int,  8],  #成交量因子 10000 正代表股份增加， 负代表股数缩减
    bonus     : [int,  4]  # 分红
  }
}
# 如果前复权，则小于time的价格除以 abs(prc-factor)  正负号表于乘除符号
# 如果后复权，则大于等于time的价格乘以 abs(prc-factor) 

# 基本财务报表
finance:{
  scale : month, # 按月增补
  write-method : { 
    sort : "time",  # 以哪个字段进行排序，只能有一个字段
    solely : "time"  # 可多个字段，表示不能重复，重复即代表修改
  },  
  fields: {
  # 字段名 | 数据类型| 长度 |
    time,  : [date,  4],   #发布日期(年月日)
    # [cycle, uint,  4],   #报表周期(年月)
    ssrq   : [uint,  4],   #上市日期(年月日)
    zgb    : [uint,  4],   #总股本(百股)
    ltag   : [uint,  4],   #流通A股(百股)
    mgsy   : [float, 4, 1, 4],  #每股收益(元)
    mgjzc  : [float, 4, 1, 4],  #每股净资产(元) 
    jzcsyl : [float, 4, 1, 2],  #净资产收益率(%) 
    mggjj  : [float, 4, 1, 2],  #每股公积金
    mgwfp  : [float, 4, 1, 4],  #每股未分配利润
    mgxj   : [float, 4, 1, 4],  #每股现金
    yysr   : [int,   4],    #营业收入(万元)  
    jlr    : [int,   4],    #净利润(万元)
    tzsy   : [int,   4],    #投资收益(万元) 
    yszk   : [int,   4],    #应收账款(万元)  
    hbzj   : [int,   4],    #货币资金(万元)  -- 总现金
    ldzj   : [int,   4],    #流动资金(万元)  -- 总现金
    sykc   : [int,   4]     #剩余库存(万元) 
  }
}

blockinfo:{
  style : json,
  write-method : { 
    solely : "code"  # 可多个字段，表示不能重复，重复即代表修改
  },
  fields: {
  # 字段名| 数据类型| 长度| 
  code    : [char, 9],    # key值是market+code的组合，
  name    : [char, 32] 
  # 默认成交量总股本和金额以百股和百元为单位，
  # 美股或其他为1股和1美元为单位，统一表示为数量的单位，必须乘以该值才是1股和1元
  }
}

blockcodes:{
  style : json,
  write-method : { 
    solely : "code"  # 可多个字段，表示不能重复，重复即代表修改
  },
  fields: {
  # 字段名| 数据类型| 长度| 
  code    : [char, 9]    # key值是market+code的组合，
  # 默认成交量总股本和金额以百股和百元为单位，
  # 美股或其他为1股和1美元为单位，统一表示为数量的单位，必须乘以该值才是1股和1元
  }
}

inblock:{
  style : json,
  write-method : { 
    solely : "code"  # 可多个字段，表示不能重复，重复即代表修改
  },
  fields: {
  # 字段名| 数据类型| 长度| 
  code    : [char, 9]    # key值是market+code的组合，
  # 默认成交量总股本和金额以百股和百元为单位，
  # 美股或其他为1股和1美元为单位，统一表示为数量的单位，必须乘以该值才是1股和1元
  }
}