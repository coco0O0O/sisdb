
//******************************************************
// Copyright (C) 2018, Martin <seerlinecoin@gmail.com>
//*******************************************************

#ifndef _STS_COLLECT_H
#define _STS_COLLECT_H

#include "sts_table.h"
#include "lw_map.h"
#include "lw_skiplist.h"
#include "lw_list.h"

/////////////////////////////////////////////////////////
//  数据库数据搜索模式
/////////////////////////////////////////////////////////
#define STS_SEARCH_NONE     -1  // 没有数据符合条件
#define STS_SEARCH_NEAR      1  // 附近的数据
#define STS_SEARCH_LEFT      2  // 附近的数据
#define STS_SEARCH_RIGHT     3  // 附近的数据
#define STS_SEARCH_OK        0  // 准确匹配的数据

#pragma pack(push,1)

// 根据结构化数组的时间序列，自动生成头尾时间，和平均间隔时间
typedef struct s_step_index {
	uint64 left;       // 最小时间
	uint64 right;   
	int count;
	uint64 step;       // 间隔时间，每条记录大约间隔时间，
}s_step_index;

// 单个股票的数据包
typedef struct sts_collect_unit{
	sts_table      *father;  // 表的指针，可以获得字段定义的相关信息
	s_step_index   *step;    // 时间索引表，这里会保存时间序列key，每条记录的指针(不申请内存)，
	s_struct_list  *value;   // 结构化数据
}sts_collect_unit;

#pragma pack(pop)

///////////////////////////////////////////////////////////////////////////
//------------------------s_step_index --------------------------------//
///////////////////////////////////////////////////////////////////////////

s_step_index *create_stepindex();
void destroy_stepindex(s_step_index *);
void stepindex_rebuild(s_step_index *, uint64 left_, uint64 right_, int count_);

///////////////////////////////////////////////////////////////////////////
//------------------------sts_collect_unit --------------------------------//
///////////////////////////////////////////////////////////////////////////

sts_collect_unit *create_sts_collect_unit(sts_table *tb_, const char *key_);
void destroy_sts_collect_unit(sts_collect_unit *);

uint64 sts_collect_unit_get_time(sts_collect_unit *unit_, int index_);

int	sts_collect_unit_recs(sts_collect_unit *unit_);
int sts_collect_unit_search(sts_collect_unit *unit_, uint64 index_);
int sts_collect_unit_search_left(sts_collect_unit *unit_, uint64 index_, int *mode_);
int sts_collect_unit_search_right(sts_collect_unit *unit_, uint64 index_, int *mode_);

int	sts_collect_unit_delete_of_range(sts_collect_unit *, int start_, int stop_); // 定位后删除
int	sts_collect_unit_delete_of_count(sts_collect_unit *, int start_, int count_); // 定位后删除

sds sts_collect_unit_get_of_range_m(sts_collect_unit *, int start_, int stop_, int format_, const char *fields_);
sds sts_collect_unit_get_of_count_m(sts_collect_unit *, int start_, int count_, int format_, const char *fields_);

int sts_collect_unit_update(sts_collect_unit *, const char *in_, size_t inLen_);

#endif  /* _STS_COLLECT_H */
