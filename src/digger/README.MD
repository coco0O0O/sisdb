### 一、 策略算法平台介绍  

    1.1. 安装部署  
    依赖于stsdb;  

    1.2. 运行调用接口

    127.0.0.1：6379 > digger.start [name] [command]  
            
            功能说明：
                启动一个策略服务

            参数说明：  
                [name] -- 为策略名称    
                [command] -- 为json格式的策略配置  

            返回数据为： 
                [name]000012  # 返回当前运行算法的唯一编号
                每次运行一个算法都是新的计算单元，这样做的原因是command可能不同，  


    127.0.0.1：6379 > digger.get xxxx000012.status 
            
            功能说明:   
                status -- 获取当前策略运行的状态  
                config -- 获取当前策略运行的配置
                money  -- 不带参数--最新的资金情况  
                          带参数--历史资金变动(需要增加开始和结束日期，若没有就返回全部)
                stock  -- 不带参数--当前持股  带参数 -- 历史持股信息
                trade  -- 不带参数--交易明细  带参数 -- 历史交易信息

    127.0.0.1：6379 > digger.stop xxxx000012 
            功能说明：
                停止一个策略服务

    127.0.0.1：6379 > digger.load xxxx000012 
            功能说明：
                重新启动一个策略服务

    127.0.0.1：6379 > digger.sub xxxx000012  
            功能说明：订阅当前算法的交易指令  

    127.0.0.1：6379 > digger.pub xxxx000012 [command]
            功能说明：发布一个交易指令，用于人工策略交易
            参数说明：[command] -- 为json格式的交易指令  
            
            ** 暂时存在,未来没用 **

    127.0.0.1：6379 > digger.set xxxx000012 [command]
            功能说明：需要对持仓和资金量进行调整时使用，然后交由算法来判定交易指令
            参数说明：[command] -- 为json格式的持仓指令  
            特别注意：
                增加股票按当前的股价，当前时间，不然总市值会不确定，影响算法的计算，股票增加会影响总资产变化；
                使用此命令输入的股票必须做好标记，以方便统计时不计入收益计算中

            ** 出现特殊异常情况,小概率使用 **

    1.3. 调试调用接口

    127.0.0.1：6379 > digger.start [name] [command]  
            
            功能说明：
                启动一个策略服务

            参数说明：  
                [name] -- 为策略名称    
                [command] -- 为json格式的策略配置  

            返回数据为： 
                [name]000012  # 返回当前运行算法的唯一编号
                每次运行一个算法都是新的计算单元，这样做的原因是command可能不同，  


    127.0.0.1：6379 > digger.get xxxx000012.status 
            
            功能说明:   
                status -- 获取当前策略运行的状态  
                config -- 获取当前策略运行的配置
                lists  -- 获取参数调整算法的结果列表，包括每种算法的收益率，成功率等信息，
                money  -- 不带参数--最新的资金情况  
                          带参数--历史资金变动(需要增加开始和结束日期，若没有就返回全部)
                stock  -- 不带参数--当前持股  带参数 -- 历史持股信息
                trade  -- 不带参数--交易明细  带参数 -- 历史交易信息

    127.0.0.1：6379 > digger.stop xxxx000012 
            功能说明：
                停止一个策略服务


### 二、 策略算法(运行期)配置文件详解  

服务端会首先加载 name.conf 为名的配置文件，并根据command中的信息，对原配置文件进行修改，(修改级别为叶端)

[command] -- 仅仅存放个性的指令

conf 的配置文件

release : {
    codes : * ,  # 准备买入的股票 * 为所有A股 待买股票可以是 "SH600600,SH600601" 中间以逗号分隔
    classify :   # 对codes股票进行分类, 分类后会在每个code返回一个 classname，再去class中匹配该类的策略
    {
        method :   
        {   
            name: filter, # 分类方法 实体函数会在函数名前加 " classify_ " 字样
            argv: { exclude: "st,SZ002100" },
            weight: 100 
        }
    },
    # 分类方法只能选择一个，返回值为 none - 表示只卖不买， 其他字符串到class中匹配
    classes :
    {
        active : # 活跃蓝筹股 最近三年振幅相对较大的 业绩不错 成交量大的
        {
            buy-methods: [ # 这里放买入股票的策略算法，
                {   name: select_buy, argv:{} weight: 100 }, # 算法返回数据为 2 0 表示观望 1 表示买入 2
                {   name: select_buy, argv:{} weight: 100 },
                {   name: select_buy, argv:{} weight: 100 }
            ],
            sell-methods: [ -- 这里放选股的策略算法，
                {   name: select_sell, argv:{} weight: 100 }, # 算法返回数据为 2 0 表示观望 1 表示卖出 2
                {   name: select_sell, argv:{} weight: 100 },
                {   name: select_sell, argv:{} weight: 100 }
            ]
            # 按权重得到的取值范围在 0..255 之间
            # 买卖分开 是因为实际运行中买卖的codes码表不同，避免重复计算
            #         买入和卖出的规则可能不同
            # 卖出减去买入的值 大于 0 就进入买入序列，小于 0 表示卖出序列， 等于 0 观望
        }
        # surprise : # 活跃黑马股 最近三年振幅相对较大的 无关业绩 无关成交量
        # stable : # 稳定的股票 最近三年振幅小，相对平稳的，比如银行股
    },
    money :  # 资金管理
    {
        all : 1000000, # 操作资金
        min : 50000,   # 单笔最小交易资金
        max : 100000,  # 单只股票最大资金
        methods : [    # 这里放股票优劣性的算法 返回一个相对的数值，再根据权重分配资金
            {name: "hold", argv:{} weight:30 },    # 持仓的加分策略，避免频繁操作
            {name: "energy", argv:{} weight:70 }   # 按能量算法
        ]
        # 可采用多种方法来排序，每种排序方法乘以权重再相加，为排序最后的标准
    },
    risk:  # 风控 主要针对已经持仓的股票，也是买入指令前最后一道关口
    {
        single : # 单只股风控
        {
            stopless: 0.062,   # 止损幅度，超过该跌幅立即止损，忽略买入信号，卖出
            sideway-day: 60,   # 横盘天数，一直横盘，忽略买入信号，卖出
            sideway-rate:0.03  # 横盘幅度，
        },
        whole : # 整体风控
        {
            down-days: 5,     # 连续市值下跌天数, 连续下跌5天 触发减仓事件
            down-reduce: 0.3  # 触发减仓事件时，减仓的资金比例
        }
    }
}

### 三、 策略算法(调试期)配置文件详解 


#### 3.2 调试时策略访问接口

调试接口时应该可以针对 algorithms 单独调试，不带入资金，仅仅判断交易的成功率
选择成功率高的策略后再带入 risk 继续测试出 成功率高的参数
最后带入资金管理，根据实际资金进行排序操作后，得出收益最高的参数

{
    "work-mode": "debug",
    "start":20160101, --  开始测试时间
    "stop":20170707,  --  结束测试时间
    "codes":"*",     --  * 为所有A股 个别股票可以是SH600600,SH600601中间以逗号分隔
    "referzs":"SH000001", --  参考指数； * 表示根据算法股票库指数, 没有表示不参考任何指数

    "algorithms":
    {  
        "max-peroid": 120, -- 起始日前多少周期数据，方便截取数据
        "methods": [ -- 这里放选股的策略算法，
          {name: "select", buy-level: 0, sell-level: 255 }
          -- 0 表示忽略该算法的买入或卖出信号
          -- 255 表示和其他算法求并集
          -- 127 表示和其他算法求交集
          -- 这里的值需要用人工智能来判定权重大小，算法返回数据为 4 项值，强烈买入 买入 全部卖出 卖出 四个状态
          {name: "select1" buy: 2, sell: 1 }
          {name: "select2" buy: 2, sell: 1 }
        ]
    }, == > 得到买入股票和卖出股票的列表
      [{code:SHxxxxxx,flag:-3..3,info:"aaxxbb"}]  
                          info 表示在何种情况下发出的指令，方便后续查询
                          3表示强烈买入  2表示增仓  1表示建仓
                         -3表示全部卖出 -2表示轻仓 -1表示减仓

    "risk": {   -- 风控  [min, max, val, step]
        "stopless":0.062,  -- 止损幅度，超过该跌幅立即止损，忽略买入信号，卖出
        "sideway-day":[30,90,5,60],   -- 横盘天数，一直横盘，忽略买入信号，卖出
        "sideway-rate":[0.03, 0.10, 0.01, 0.04]  -- 横盘幅度
        "down-days": [2,10,1,5] -- 连续市值下跌天数, 连续下跌5天 触发减仓事件
        "down-reduce":[0.1, 0.5, 0.1, 0.3] -- 触发减仓事件时，减仓的资金比例
        "methods": { -- 一定不能买或者必须要卖的股票
           -- 传入买入股票列表，处理后返回
        }
    },
    -- 风控后会把需要卖出的股票发出卖出指令，同时把风控卖出的股票从买入列表中清除
    -- 这里可以保留 卖出 减仓的信号，
    -- 可以获得当前持仓量和现金数量，已经持仓的可能会加分，比例在methods中计算
    "money": {   -- 资金管理 若没有该字段，只统计策略算法的胜率
        "all-money":1000000,   -- 所有资金
        "min-money":[10000,150000,10000,50000],    -- 每笔交易资金量
        "max-money":500000,   -- 一只股票最大使用资金量，即使发出买入信号，也不超过
        "methods": [ -- 当股票可选过多，采用以下算法控制顺序
          -- 每种算法返回的值在-100..100之间，以表示卖出和买入的强烈度，这样以后可以加入很多走势特征来进行优选
          "energy":[80,60,5]  // 最大权重，当前权重，每次变化
          "hold":[10,10,1] -- 已经持仓的加分策略，避免频繁操作，比如已经持仓的并且发出买进信号的，加多点分
                                         已经持仓但没有买入信号的，少点分
        ], -- 可采用多种方法来排序，每种排序方法乘以权重再相加，为排序最后的标准
    },
    -- 排序算法根据以下值来做统一数据评判
       一个字节表示 2，4，8，64种状态
       00 : 2 -- 01 : 4 -- 10 : 8 -- 11 : 64
       2 表示布尔型，仅仅是做一个判断，比如是否st，是否国资控股等
       4 只有3个有效值，买入1 卖出2 观望0
       8 7个有效值 买入3种程度 卖出3种程度 观望
       64 当不确定买入还是卖出，仅仅对股票进行评估其上涨下跌概率时，用这个来描述其程度

       每个算法根据自己数据的特性返回以上4中格式数据，最后都会被转换为255*权重的数值，然后相加；
       相当于对所有的干扰项进行虚拟数据标准化
       权重的计算可以参考贝叶斯算法，利用机器学习来完善--- 后期完善

    -- 先根据风控后的卖出和减仓信号，合并买入信号，生成 卖出 减仓的指令， 然后再
       从头开始，发出 买入，增持，观望(具备买入条件，但超出最大资金量)的指令

    "methods": []
    {
       --  财录策略配置,下面不同算法对应的参数集合不同
      "select":{  -- 采用select方法，参数如下
        "peroid" : [ 10, 80, 1, 60] -- min:10, max:80, step:1, value:60, 所有周期受max-peroid限制
        "buy-level" : [ 0, 1, 1, 0],
        "sell-level" : [ 0, 1, 1, 0]
      }
      "energy":{ -- 采用energy方法，参数如下
        "range" : [ 20, 60, 1, 10] -- min:10, max:80, step:1, value:60,
        "上影线": [] -- 其他特征值的权重
        "下影线": [] -- 其他特征值的权重
      }
   }
   "must-filter": []
}
### 四、 策略算法函数集  

### 五、 策略算法分布运算详解  
